<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Video Slice Tool</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    background: #1a1a1a; color: #e0e0e0;
    height: 100vh; overflow: hidden;
  }

  /* Drop overlay */
  #dropOverlay {
    display: none; position: fixed; inset: 0; z-index: 100;
    background: rgba(42, 110, 216, 0.15);
    border: 3px dashed #4a8ef5;
    justify-content: center; align-items: center;
    font-size: 1.6em; color: #7ab8f5;
  }
  #dropOverlay.visible { display: flex; }

  /* Landing */
  #landing {
    height: 100vh; display: flex;
    justify-content: center; align-items: center;
  }
  .landing-content { text-align: center; }
  .landing-icon { font-size: 4em; margin-bottom: 16px; opacity: 0.4; }
  .landing-text { font-size: 1.2em; color: #888; margin-bottom: 6px; }
  .landing-or { color: #555; margin-bottom: 12px; }

  button {
    background: #3a3a3a; color: #e0e0e0; border: 1px solid #555;
    padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 0.9em;
  }
  button:hover { background: #4a4a4a; }
  button:disabled { opacity: 0.4; cursor: default; }
  button.primary { background: #2a6ed8; border-color: #2a6ed8; color: #fff; }
  button.primary:hover { background: #3a7ee8; }
  button.primary:disabled { background: #2a4a78; border-color: #2a4a78; }

  /* Main UI */
  #main {
    height: 100vh; display: flex; flex-direction: column;
    padding: 10px 16px 16px;
  }

  /* Header */
  .header {
    display: flex; align-items: center; gap: 12px;
    padding-bottom: 8px; flex-shrink: 0;
  }
  .header .filename {
    font-family: monospace; font-size: 0.95em; color: #aaa;
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    flex: 1;
  }
  .header button { font-size: 0.8em; padding: 4px 12px; flex-shrink: 0; }

  /* Video */
  .video-wrap {
    flex: 1; min-height: 0; display: flex;
    align-items: center; justify-content: center;
    background: #000; border-radius: 6px; overflow: hidden;
  }
  video { width: 100%; height: 100%; object-fit: contain; }
  .video-error {
    color: #666; font-size: 1.1em;
  }

  /* Controls below video */
  .controls { flex-shrink: 0; padding-top: 8px; }

  /* Scrubber */
  input[type="range"] {
    -webkit-appearance: none; width: 100%; height: 8px;
    background: #333; border-radius: 4px; outline: none; cursor: pointer;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; width: 18px; height: 18px;
    background: #6a9ef5; border-radius: 50%; cursor: pointer;
  }
  input[type="range"]::-moz-range-thumb {
    width: 18px; height: 18px; background: #6a9ef5;
    border-radius: 50%; cursor: pointer; border: none;
  }
  input[type="range"]::-moz-range-track {
    background: #333; height: 8px; border-radius: 4px;
  }

  /* Transport row */
  .transport {
    display: flex; align-items: center; justify-content: center;
    gap: 4px; margin-top: 8px;
  }
  .transport button {
    font-family: monospace; font-size: 0.8em;
    padding: 5px 8px; min-width: 38px;
  }
  .time-display {
    font-family: monospace; font-size: 1em; color: #ccc;
    min-width: 180px; text-align: center;
    padding: 0 8px;
  }
  .meta {
    text-align: center; font-family: monospace;
    font-size: 0.8em; color: #666; margin-top: 4px;
  }

  /* Slice controls */
  .slice-controls {
    flex-shrink: 0; padding-top: 10px;
    display: flex; align-items: center; gap: 12px; flex-wrap: wrap;
  }
  .tc-group {
    display: flex; align-items: center; gap: 6px;
  }
  .tc-group label { font-size: 0.85em; color: #888; }
  .tc-group input[type="text"] {
    width: 100px; background: #111; border: 1px solid #444;
    color: #e0e0e0; padding: 6px 8px; border-radius: 4px;
    font-family: monospace; font-size: 0.9em; text-align: center;
  }
  .tc-group input[type="text"]:focus { outline: none; border-color: #6a9ef5; }
  .tc-group button { font-size: 0.78em; padding: 6px 8px; }

  .status {
    font-size: 0.85em; padding: 6px 10px; border-radius: 4px; display: none;
  }
  .status.visible { display: inline-block; }
  .status.running { background: #1e2d3d; color: #7ab8f5; }
  .status.complete { background: #1e3d1e; color: #7af57a; }
  .status.error { background: #3d1e1e; color: #f57a7a; }

  .download-link {
    display: inline-block; padding: 6px 14px;
    background: #2a6ed8; color: #fff; text-decoration: none;
    border-radius: 4px; font-size: 0.85em;
  }
  .download-link:hover { background: #3a7ee8; }
</style>
</head>
<body>

<div id="dropOverlay">Drop video file here</div>

<div id="landing">
  <div class="landing-content">
    <div class="landing-icon">&#127916;</div>
    <div class="landing-text">Drop a video file here</div>
    <div class="landing-or">or</div>
    <button onclick="openFile()">Open File</button>
  </div>
</div>

<div id="main" style="display:none">
  <div class="header">
    <span class="filename" id="fileName"></span>
    <button onclick="openFile()">Change</button>
  </div>

  <div class="video-wrap">
    <video id="player"></video>
    <div class="video-error" id="videoError" style="display:none">Preview unavailable for this codec</div>
  </div>

  <div class="controls">
    <input type="range" id="scrubber" min="0" max="100" step="any" value="0">
    <div class="transport">
      <button id="playBtn" onclick="togglePlay()" title="Space">&#9654;</button>
      <button onclick="step(-60)">-1m</button>
      <button onclick="step(-10)">-10s</button>
      <button onclick="step(-1)">-1s</button>
      <button onclick="stepFrame(-1)">&lt;1f</button>
      <span class="time-display" id="timeDisplay">0:00.0 / 0:00</span>
      <button onclick="stepFrame(1)">1f&gt;</button>
      <button onclick="step(1)">+1s</button>
      <button onclick="step(10)">+10s</button>
      <button onclick="step(60)">+1m</button>
    </div>
    <div class="meta" id="videoMeta"></div>
  </div>

  <div class="slice-controls">
    <div class="tc-group">
      <label>Start:</label>
      <input type="text" id="startTC" placeholder="0:00">
      <button onclick="useCurrentTime('start')">Set</button>
    </div>
    <div class="tc-group">
      <label>Stop:</label>
      <input type="text" id="stopTC" placeholder="1:00">
      <button onclick="useCurrentTime('stop')">Set</button>
    </div>
    <button class="primary" id="sliceBtn" onclick="startSlice()">Slice</button>
    <span class="status" id="statusBox"></span>
    <span id="downloadArea"></span>
  </div>
</div>

<script>
  const player = document.getElementById('player');
  const videoError = document.getElementById('videoError');
  const scrubber = document.getElementById('scrubber');
  const playBtn = document.getElementById('playBtn');
  const timeDisplay = document.getElementById('timeDisplay');
  const statusBox = document.getElementById('statusBox');
  const downloadArea = document.getElementById('downloadArea');
  const sliceBtn = document.getElementById('sliceBtn');

  let selectedFile = '';
  let videoDuration = 0;
  let frameDuration = 1 / 30;
  let isScrubbing = false;
  let eventSource = null;

  // --- Drop handling ---
  let dragCounter = 0;
  const dropOverlay = document.getElementById('dropOverlay');

  document.addEventListener('dragenter', e => {
    e.preventDefault();
    dragCounter++;
    dropOverlay.classList.add('visible');
  });
  document.addEventListener('dragleave', e => {
    e.preventDefault();
    dragCounter--;
    if (dragCounter <= 0) { dragCounter = 0; dropOverlay.classList.remove('visible'); }
  });
  document.addEventListener('dragover', e => e.preventDefault());
  document.addEventListener('drop', e => {
    e.preventDefault();
    dragCounter = 0;
    dropOverlay.classList.remove('visible');

    // Try text/uri-list (Linux file manager drag)
    const uriList = e.dataTransfer.getData('text/uri-list');
    if (uriList) {
      const line = uriList.split(/\r?\n/).find(l => l && !l.startsWith('#'));
      if (line && line.trim().startsWith('file://')) {
        loadVideo(decodeURIComponent(line.trim().slice(7)));
        return;
      }
    }
    // Try text/plain
    const text = (e.dataTransfer.getData('text/plain') || '').trim();
    if (text.startsWith('file://')) {
      loadVideo(decodeURIComponent(text.split(/\r?\n/)[0].trim().slice(7)));
      return;
    }
    if (text.startsWith('/')) {
      loadVideo(text.split(/\r?\n/)[0].trim());
      return;
    }
    alert('Could not read file path from drop. Try the Open File button.');
  });

  // --- File picker ---
  async function openFile() {
    try {
      const res = await fetch('/api/pick');
      const data = await res.json();
      if (data.path) {
        loadVideo(data.path);
      } else if (data.error === 'no_picker') {
        const path = prompt('Enter video file path:');
        if (path) loadVideo(path.trim());
      } else if (data.error !== 'cancelled') {
        alert(data.error);
      }
    } catch (err) {
      alert('Failed to open file picker: ' + err);
    }
  }

  // --- Load video ---
  function loadVideo(path) {
    selectedFile = path;
    document.getElementById('fileName').textContent = path.split('/').pop();
    document.getElementById('landing').style.display = 'none';
    document.getElementById('main').style.display = '';

    // Reset
    statusBox.className = 'status';
    downloadArea.innerHTML = '';
    player.removeAttribute('src');
    player.style.display = '';
    videoError.style.display = 'none';
    if (eventSource) { eventSource.close(); eventSource = null; }

    // Probe first, then decide how to load
    fetch('/api/probe?path=' + encodeURIComponent(path))
      .then(r => r.json())
      .then(info => {
        if (info.error) {
          videoError.textContent = 'Probe error: ' + info.error;
          videoError.style.display = '';
          player.style.display = 'none';
          return;
        }
        showMeta(info);
        if (info.playable) {
          setVideoSrc(path);
        } else {
          prepareWorkingCopy(path, info.format_status);
        }
      });
  }

  function showMeta(info) {
    const parts = [];
    if (info.codec_name) parts.push(info.codec_name);
    if (info.width && info.height) parts.push(info.width + '\u00d7' + info.height);
    if (info.r_frame_rate) {
      const [num, den] = info.r_frame_rate.split('/');
      if (den && den !== '0') {
        const fps = Math.round(num / den);
        parts.push(fps + 'fps');
        frameDuration = 1 / (num / den);
      }
    }
    if (info.duration) {
      videoDuration = info.duration;
      parts.push(formatTime(info.duration));
    }
    if (info.has_audio) parts.push('audio');
    document.getElementById('videoMeta').textContent = parts.join(' \u00b7 ');
  }

  function setVideoSrc(path) {
    player.src = '/video?path=' + encodeURIComponent(path) + '&t=' + Date.now();
    player.style.display = '';
    videoError.style.display = 'none';
    player.onerror = () => {
      player.style.display = 'none';
      videoError.textContent = 'Preview unavailable for this codec';
      videoError.style.display = '';
    };
  }

  function prepareWorkingCopy(path, formatStatus) {
    const label = formatStatus === 'remux' ? 'Remuxing to MP4...' : 'Converting to H.264 MP4...';
    statusBox.className = 'status visible running';
    statusBox.textContent = label;

    fetch('/api/prepare', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({path: path})
    })
    .then(r => r.json())
    .then(data => {
      if (data.status === 'ready') {
        statusBox.className = 'status';
        setVideoSrc(path);
      } else if (data.job_id) {
        listenToPrepare(data.job_id, path);
      } else if (data.error) {
        statusBox.className = 'status visible error';
        statusBox.textContent = data.error;
      }
    })
    .catch(err => {
      statusBox.className = 'status visible error';
      statusBox.textContent = 'Conversion failed: ' + err;
    });
  }

  function listenToPrepare(jobId, path) {
    const es = new EventSource('/api/job/' + jobId + '/stream');
    es.onmessage = function(e) {
      const data = JSON.parse(e.data);
      statusBox.textContent = data.message;
      if (data.status === 'complete') {
        statusBox.className = 'status';
        setVideoSrc(path);
        es.close();
      } else if (data.status === 'error') {
        statusBox.className = 'status visible error';
        es.close();
      }
    };
    es.onerror = function() {
      es.close();
      statusBox.className = 'status';
      setVideoSrc(path);
    };
  }

  // --- Scrubber ---
  player.addEventListener('loadedmetadata', () => {
    scrubber.max = player.duration || 100;
    videoDuration = player.duration;
  });
  player.addEventListener('timeupdate', () => {
    if (!isScrubbing) scrubber.value = player.currentTime;
    updateTimeDisplay();
  });

  scrubber.addEventListener('mousedown', () => isScrubbing = true);
  scrubber.addEventListener('touchstart', () => isScrubbing = true);
  scrubber.addEventListener('input', () => {
    player.currentTime = parseFloat(scrubber.value);
    updateTimeDisplay();
  });
  document.addEventListener('mouseup', () => { isScrubbing = false; });
  document.addEventListener('touchend', () => { isScrubbing = false; });

  function updateTimeDisplay() {
    timeDisplay.textContent = formatTime(player.currentTime) + ' / ' + formatTime(videoDuration);
  }

  // --- Play / Pause ---
  function togglePlay() {
    if (player.paused) { player.play(); playBtn.innerHTML = '&#9646;&#9646;'; }
    else { player.pause(); playBtn.innerHTML = '&#9654;'; }
  }
  player.addEventListener('pause', () => { playBtn.innerHTML = '&#9654;'; });
  player.addEventListener('play', () => { playBtn.innerHTML = '&#9646;&#9646;'; });

  // --- Stepping ---
  function step(seconds) {
    player.pause();
    player.currentTime = Math.max(0, Math.min(player.currentTime + seconds, videoDuration));
  }
  function stepFrame(dir) {
    player.pause();
    player.currentTime = Math.max(0, Math.min(player.currentTime + dir * frameDuration, videoDuration));
  }

  // Spacebar play/pause
  document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT') return;
    if (e.code === 'Space') { e.preventDefault(); togglePlay(); }
  });

  // --- Timecodes ---
  function useCurrentTime(which) {
    const tc = formatTimecode(player.currentTime);
    if (which === 'start') document.getElementById('startTC').value = tc;
    else document.getElementById('stopTC').value = tc;
  }

  // --- Slice ---
  function startSlice() {
    if (!selectedFile) return;
    const start = document.getElementById('startTC').value.trim();
    const stop = document.getElementById('stopTC').value.trim();
    if (!start || !stop) { alert('Set both start and stop times'); return; }

    sliceBtn.disabled = true;
    statusBox.className = 'status visible running';
    statusBox.textContent = 'Starting...';
    downloadArea.innerHTML = '';
    if (eventSource) { eventSource.close(); eventSource = null; }

    fetch('/api/slice', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({path: selectedFile, start: start, stop: stop})
    })
    .then(r => r.json())
    .then(data => {
      if (data.error) {
        statusBox.className = 'status visible error';
        statusBox.textContent = data.error;
        sliceBtn.disabled = false;
        return;
      }
      listenToJob(data.job_id);
    })
    .catch(err => {
      statusBox.className = 'status visible error';
      statusBox.textContent = 'Request failed: ' + err;
      sliceBtn.disabled = false;
    });
  }

  function listenToJob(jobId) {
    eventSource = new EventSource('/api/job/' + jobId + '/stream');
    eventSource.onmessage = function(e) {
      const data = JSON.parse(e.data);
      statusBox.textContent = data.message;
      if (data.status === 'complete') {
        statusBox.className = 'status visible complete';
        downloadArea.innerHTML = '<a class="download-link" href="/api/job/' + jobId + '/download">Download</a>';
        sliceBtn.disabled = false;
        eventSource.close(); eventSource = null;
      } else if (data.status === 'error') {
        statusBox.className = 'status visible error';
        sliceBtn.disabled = false;
        eventSource.close(); eventSource = null;
      }
    };
    eventSource.onerror = function() {
      eventSource.close(); eventSource = null;
      fetch('/api/job/' + jobId).then(r => r.json()).then(data => {
        statusBox.textContent = data.message;
        if (data.status === 'complete') {
          statusBox.className = 'status visible complete';
          downloadArea.innerHTML = '<a class="download-link" href="/api/job/' + jobId + '/download">Download</a>';
        } else if (data.status === 'error') {
          statusBox.className = 'status visible error';
        }
        sliceBtn.disabled = false;
      });
    };
  }

  // --- Formatting ---
  function formatTime(sec) {
    if (!sec || isNaN(sec)) return '0:00';
    const h = Math.floor(sec / 3600);
    const m = Math.floor((sec % 3600) / 60);
    const s = Math.floor(sec % 60);
    if (h > 0) return h + ':' + String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');
    return m + ':' + String(s).padStart(2, '0');
  }
  function formatTimecode(sec) {
    const h = Math.floor(sec / 3600);
    const m = Math.floor((sec % 3600) / 60);
    const s = sec % 60;
    const sStr = s < 10 ? '0' + s.toFixed(1) : s.toFixed(1);
    if (h > 0) return h + ':' + String(m).padStart(2, '0') + ':' + sStr;
    return m + ':' + sStr;
  }
</script>
</body>
</html>
